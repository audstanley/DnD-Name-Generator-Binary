package generator

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"github.com/goccy/go-yaml"
)

// Names represents the data used for generating the file
type Names struct {
	PackageName string
	Names       []string
}

func readNamesFromFile() ([]string, error) {
	filename := "generator/names.txt"
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var names []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		names = append(names, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return names, nil
}

func generateNamesFile(names []string) error {

	// Trim whitespace from each name, just in case.
	for i, name := range names {
		names[i] = strings.TrimSpace(name)
	}

	var newNames []string
	currentGroup := []string{}
	for i, name := range names {
		isLastElement := len(names) == i+1
		isLastInGroup := len(currentGroup) == 4 || isLastElement // Check for last in group or last element overall

		currentGroup = append(currentGroup, fmt.Sprintf("\"%s\"", name))

		if isLastInGroup {
			newNames = append(newNames, strings.Join(currentGroup, ",")+",")
			currentGroup = []string{} // Clear the current group for the next
			if !isLastElement {       // Add newline and indentation if not the absolute last element
				newNames = append(newNames, "\n\t\t")
			}
		}
	}

	// Define the template for the generated file (same as before)
	tmpl := template.Must(template.New("names").Parse(`package {{.PackageName}}
// This file is generated by the generator tool; DO NOT EDIT

var NamesList = []string{
	{{- range .Names }}{{.}}{{end -}}} // List of names for DnD characters
`))

	// Define the data for the template
	data := Names{
		PackageName: "cmd",
		Names:       newNames,
	}

	// Create the output file (same as before)
	f, err := os.OpenFile("cmd/names.go", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	// Generate the file content and write it to the output file (same as before)
	return tmpl.Execute(f, data)
}

// Generate the names.go file by reading names from a file
func Generate() error {
	names, err := readNamesFromFile()
	if err != nil {
		return err
	}

	err = generateNamesFile(names)
	if err != nil {
		return err
	} else {
		fmt.Println("Generated cmd/names.go file successfully")
	}

	// Generate all the text files for the species
	fmt.Println("Generating species text files, if they don't already exist...")
	cwd, _ := os.Getwd()
	os.Chdir("generator")
	err = ProcessYAMLAndCreateFiles("names.yaml")
	if err != nil {
		os.Chdir(cwd)
		return err
	}
	os.Chdir(cwd)

	return nil
}

// ProcessSpeciesData function processes the provided YAML data and creates folders and text files
func ProcessSpeciesDataForFolderStructredTextData(speciesMap map[string]interface{}) error {
	fmt.Println("Processing species data...")
	fmt.Println("Creating folders and text files...")
	fmt.Println("Species data:", speciesMap)

	SpeciesStructure := []SpeciesInfo{}

	for species, v := range speciesMap {
		SpeciesStructure = append(SpeciesStructure, SpeciesInfo{
			NameOfSpecies: v.(map[string]interface{})["NameOfSpecies"].(string),
			Variable:      v.(map[string]interface{})["Variable"].(string),
			TextFileNames: []string{},
		})
		latestSpecies := SpeciesStructure[len(SpeciesStructure)-1]
		for _, textFileName := range v.(map[string]interface{})["TextFileNames"].([]interface{}) {
			fmt.Println("species:", species, "variable:", v.(map[string]interface{})["Variable"], "textFileName:", textFileName)
			filepath := latestSpecies.NameOfSpecies + "/" + latestSpecies.NameOfSpecies + "-" + textFileName.(string) + ".txt"
			latestSpecies.TextFileNames = append(latestSpecies.TextFileNames, filepath)
		}

		fmt.Println("species value:", v)
		// Create folder for the species
		if err := os.MkdirAll(species, os.ModePerm); err != nil {
			switch {
			case os.IsExist(err):
				fmt.Printf("\ngenerator/%s already exists. Skipping creation.\n", species)
			default:
				return fmt.Errorf("error creating folder %s: %w", species, err)
			}
		} else {
			fmt.Printf("\ngenerator/%s folder available\n", species)
		}

		for _, textFileNames := range latestSpecies.TextFileNames {
			// Check if the file already exists
			_, err := os.Stat(textFileNames)
			if err != nil && !os.IsNotExist(err) {
				// Handle other errors
				return fmt.Errorf("error checking file %s: %w", textFileNames, err)
			}

			// If file doesn't exist, create it
			if err == nil {
				fmt.Printf("  generator/%s already exists. Skipping creation.\n", textFileNames)
				continue // Skip to next prefix
			}

			// Create empty text file
			err = ioutil.WriteFile(textFileNames, []byte{}, 0644)
			if err != nil && !os.IsNotExist(err) { // Check for specific os.IsNotExist error
				fmt.Printf("Error creating file %s: %v\n", textFileNames, err)
			}
		}
	}
	return nil
}

type SpeciesData struct {
	// Other fields in the struct (if any)
	Species map[string]SpeciesInfo `yaml:"Species"` // Assuming data comes from a YAML file
}

type SpeciesInfo struct {
	NameOfSpecies string   `yaml:"NameOfSpecies"`           // Field for species name
	Variable      string   `yaml:"Variable,omitempty"`      // Field for your string value
	TextFileNames []string `yaml:"TextFileNames,omitempty"` // Field for list of text files
	// Other fields specific to species data (if any)
}

var speciesData SpeciesData

// ProcessYAMLAndCreateFiles function opens, parses YAML data and creates folders/files
func ProcessYAMLAndCreateFiles(filePath string) error {
	// Read YAML file content
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("error reading YAML file %s: %w", filePath, err)
	}

	// Parse YAML data into a map
	var speciesData map[string]map[string]interface{}
	err = yaml.Unmarshal(data, &speciesData)
	if err != nil {
		return fmt.Errorf("error parsing YAML data: %w", err)
	}

	speciesMap := speciesData["Species"] // Access the map associated with "Species" key

	// Now you can use speciesMap as a map[string]interface{}
	if speciesMap != nil {
		// Get keys from the speciesMap (using loop)
		speciesKeys := make([]string, 0, len(speciesMap))
		for key := range speciesMap {
			speciesKeys = append(speciesKeys, key)
		}
		fmt.Println(speciesKeys)
	} else {
		fmt.Println("Species data not found")
	}

	// Call ProcessSpeciesData to create folders and files
	return ProcessSpeciesDataForFolderStructredTextData(speciesMap)
}
