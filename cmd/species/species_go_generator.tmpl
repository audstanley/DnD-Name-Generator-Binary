package species
// This code is generated by cmd/generator/generator.go. DO NOT EDIT.
{{define "imports"}}
import (
	"fmt"
	"math/rand"
	"time"
    "os"

	"github.com/spf13/cobra"
)
{{end}}
{{define "GlobalSpecies"}}
type Name struct {
    First string
    Last string
    Special string
    Location string
    Gender string
}

type GenericSpecies struct {
	GlobalVariableName string   `mapstructure:"global_variable_name"`
	FirstFNames        []string `mapstructure:"first_f_names"`
	FirstMNames        []string `mapstructure:"first_m_names"`
	FirstNBNames       []string `mapstructure:"first_nb_names"`
	FirstNames         []string `mapstructure:"first_names"`
	LastNames          []string `mapstructure:"last_names"`
	SpecialNames       []string `mapstructure:"special_names"`
	LocationNames      []string `mapstructure:"location_names"`
    FullName           Name
}

func (species GenericSpecies) GetFirstAndLastByGender(p Print) (string, error) {
    // Seed the random number generator
    // Use a new source for randomness (recommended)
    source := rand.NewSource(time.Now().UnixNano())
    random := rand.New(source)

    // Check if the list is less than 100
    if len(species.LastNames) == 0 {
        if p.Female && len(species.FirstFNames) == 0 {
            fmt.Printf("FirstFNames for %s List is less than 100\n", species.GlobalVariableName)
        } else if p.Male && len(species.FirstMNames) == 0 {
            fmt.Printf("FirstMNames for %s List is less than 100\n", species.GlobalVariableName)
        } else if p.Nonbinary && len(species.FirstNBNames) == 0 {
            fmt.Printf("FirstNBNames for %s List is less than 100\n", species.GlobalVariableName)
        }
        fmt.Printf("LastNames for %s List is less than 100\n", species.GlobalVariableName)
        os.Exit(1)
        return "", fmt.Errorf("LastNames for %s List is less than 100", species.GlobalVariableName)
    } else if len(species.FirstFNames) == 0 && p.Female {
        fmt.Printf("FirstFNames for %s List is less than 100\n", species.GlobalVariableName)
        os.Exit(1)
        return "", fmt.Errorf("FirstFNames for %s List is less than 100", species.GlobalVariableName)
    } else if len(species.FirstMNames) == 0 && p.Male{
        fmt.Printf("FirstMNames for %s List is less than 100\n", species.GlobalVariableName)
        os.Exit(1)
        return "", fmt.Errorf("FirstMNames for %s List is less than 100", species.GlobalVariableName)
    } else if len(species.FirstNBNames) == 0 && p.Nonbinary{
        fmt.Printf("FirstNBNames for %s List is less than 100\n", species.GlobalVariableName)
        os.Exit(1)
        return "", fmt.Errorf("FirstNBNames for %s List is less than 100", species.GlobalVariableName)
    }
    if p.Female {
        index1 := random.Intn(len(species.FirstFNames))
        index2 := random.Intn(len(species.LastNames))
        for index1 == index2 {
            index2 = random.Intn(len(species.LastNames))
        }
        species.FullName.First = species.FirstFNames[index1]
        species.FullName.Last = species.LastNames[index2]
        species.FullName.Gender = "female"
        return "", nil
    } else if p.Male {
        index1 := random.Intn(len(species.FirstMNames))
        index2 := random.Intn(len(species.LastNames))
        for index1 == index2 {
            index2 = random.Intn(len(species.LastNames))
        }
        species.FullName.First = species.FirstMNames[index1]
        species.FullName.Last = species.LastNames[index2]
        species.FullName.Gender = "male"
        return "", nil
    } else if p.Nonbinary {
        index1 := random.Intn(len(species.FirstNBNames))
        index2 := random.Intn(len(species.LastNames))
        for index1 == index2 {
            index2 = random.Intn(len(species.LastNames))
        }
        species.FullName.First = species.FirstNBNames[index1]
        species.FullName.Last = species.LastNames[index2]
        species.FullName.Gender = "nonbinary"
        return "", nil
    }

    // Check special and location flags from Print struct before assigning values
    if p.SpecialFlag {
        if len(species.SpecialNames) > 100 {
            index := random.Intn(len(species.SpecialNames))
            species.FullName.Special = species.SpecialNames[index]
        } else {
            return "", fmt.Errorf("SpecialNames for %s List is less than 100", species.GlobalVariableName)
        }
    }
    if p.LocationFlag {
        if len(species.LocationNames) > 100 {
            index := random.Intn(len(species.LocationNames))
            species.FullName.Location = species.LocationNames[index]
        } else {
            return "", fmt.Errorf("LocationNames for %s List is less than 100", species.GlobalVariableName)
        }
    }
    return "", fmt.Errorf("Somthing went wrong when processing the names")
}

// GetLocationOfOrigin returns a random location name
func (species GenericSpecies) GetLocationOfOrigin() (string, error) {
    if len(species.LocationNames) > 100 {
        // Seed the random number generator
        // Use a new source for randomness (recommended)
        source := rand.NewSource(time.Now().UnixNano())
        random := rand.New(source)
        index := random.Intn(len(species.LocationNames))
        return species.LocationNames[index], nil
    } else {
        return "", fmt.Errorf("LocationNames for %s List is less than 100", species.GlobalVariableName)
    }
}

// GetSpecialName for species
func (species GenericSpecies) GetSpecialName() (string, error) {
    if len(species.SpecialNames) > 100 {
        // Seed the random number generator
        // Use a new source for randomness (recommended)
        source := rand.NewSource(time.Now().UnixNano())
        random := rand.New(source)
        index := random.Intn(len(species.SpecialNames))
        return species.SpecialNames[index], nil
    } else {
        return "", fmt.Errorf("SpecialNames for %s List is less than 100", species.GlobalVariableName)
    }
}

func (species GenericSpecies) GetRandomFirstAndLastName(cmd *cobra.Command) error {
	// Seed the random number generator
	// Use a new source for randomness (recommended)
	source := rand.NewSource(time.Now().UnixNano())
	random := rand.New(source)

	// Pick five random indices
    if len(species.FirstFNames) > 100 && len(species.FirstMNames) > 100 && len(species.FirstNBNames) > 100 && len(species.LastNames) > 100 {
        index1 := random.Intn(len(species.FirstFNames))
        index2 := random.Intn(len(species.FirstMNames))
        index3 := random.Intn(len(species.FirstNBNames))
        index4 := random.Intn(len(species.LastNames))

        // Ensure indices are unique (avoid duplicates)
        for index1 == index4 {
            index2 = random.Intn(len(species.LastNames))
        }
        for index2 == index4 {
            index2 = random.Intn(len(species.LastNames))
        }
        for index3 == index4 {
            index2 = random.Intn(len(species.LastNames))
        }
        firstNames := []string{species.FirstFNames[index1], species.FirstMNames[index2], species.FirstNBNames[index3]}
        gender := []string{"female", "male", "nonbinary"}
        index5 := random.Intn(len(firstNames))

        fmt.Printf("%s: %s %s\n", gender[index5], firstNames[index5], species.LastNames[index2])
    } else {
        fmt.Printf("FirstFNames, FirstMNames, FirstNBNames, or LastNames for %s List is less than 100\n", cmd.Name())
    }
	return nil
}

{{range $i, $v := .Species}}var {{$v.GlobalVariableName}} struct{ GenericSpecies }{{printf "\n"}}{{end}}

var LocationNames []string

func (species GenericSpecies) Init() {
{{range $i, $v := .Species}}    {{$v.GlobalVariableName}}.GlobalVariableName = "{{$v.GlobalVariableName}}"{{printf "\n"}}{{end}}
{{range $i, $v := .Species}}    {{$v.GlobalVariableName}}.FirstFNames = []string{ {{range $j, $y := $v.Names.FirstFNames}}"{{$y}}", {{end}} }{{printf "\n"}}{{end}}
{{range $i, $v := .Species}}    {{$v.GlobalVariableName}}.FirstMNames = []string{ {{range $j, $y := $v.Names.FirstMNames}}"{{$y}}", {{end}} }{{printf "\n"}}{{end}}
{{range $i, $v := .Species}}    {{$v.GlobalVariableName}}.FirstNBNames = []string{ {{range $j, $y := $v.Names.FirstNBNames}}"{{$y}}", {{end}} }{{printf "\n"}}{{end}}
{{range $i, $v := .Species}}    {{$v.GlobalVariableName}}.LastNames = []string{ {{range $j, $y := $v.Names.Last}}"{{$y}}", {{end}} }{{printf "\n"}}{{end}}
{{range $i, $v := .Species}}    {{$v.GlobalVariableName}}.SpecialNames = []string{ {{range $j, $y := $v.Names.Special}}"{{$y}}", {{end}} }{{printf "\n"}}{{end}}
}
{{end}}{{template "imports" .}}{{template "GlobalSpecies" .}}